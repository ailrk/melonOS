; Reference:
; Intel® 64 and IA-32 Architectures Software Developer’s Manual Vol3 6-13

; When cpu calls the interrupt handler, the stack will save the following
; information
; ---------------
;  esp0: ss
;        esp       ; ss and esp are only saved when the PL changes.
;        eflags
;        cs
;        eip
;        errcode
;  esp:  
; ---------------
;
; For setting up the trapframe we save more registers so the stack
; looks like this:
; ---------------
;  esp0: ss
;        esp
;        eflags
;        cs
;        eip
;        errcode
;        trapno
;        <segment regs: ds es fs gs>
;        <registers saved by pusha>
;  esp:  
; ---------------
; 
; An interrupt will calls vector{n} handler in vectors.s
; (generated by vectors.py), which first push the trap number
; to the stack, then jump to `trapgo`. `trapgo` will setup the
; trap frame then jump to `trap` which handles the interrupt.

extern trap
global trapgo
trapgo:
    ; build trap frame
    ; push vector{n} is performed in vectors.s
    push ds
    push es
    push fs
    push gs
    pusha

    push esp
    call trap
    add esp, 0x4

; fall through
; `trapret` restore the context before the trap
global trapret
trapret:
    popa
    pop gs
    pop fs
    pop es
    pop ds
    add esp, 0x8 ; trapno and errcode
    iret
